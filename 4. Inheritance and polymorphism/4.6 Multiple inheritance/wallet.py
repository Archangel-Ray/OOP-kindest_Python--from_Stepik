# Declare a class named Money (money), whose objects are created by the command:
#
# money = money(value)
#
# where value is any number (integer or real).
# If a non-numeric value is specified, then an exception is generated by the command:
#
# raise TypeError('sum must be a number')
#
# Each object of this class must have a local _money attribute with the corresponding value.
# Also, the Money class should have a property object:
#
# money - for writing and reading a value from the _money attribute.
#
# In conjunction with the Money class, another class works:
#
# class MoneyOperators:
#     def __add__(self, other):
#         if type(other) in (int, float):
#             return self.__class__(self.money + others)
#
#         if type(self) != type(other):
#             raise TypeError('Miscellaneous object types')
#
#         return self.__class__(self.money + other.money)
#
# It defines how arithmetic operators work. This example describes an algorithm for adding two objects
# of the Money class (or objects of its child classes).
#
# Notice how the __add__() method is implemented in this class. It is universal when working with any objects of
# the Money class or its child classes. Here the __class__ attribute is a reference to the object's class self.
# With __class__ , you can create objects of the same class as self.
#
# You need to add a similar implementation of the subtraction operator to the MoneyOperators class.
#
# Based on two classes (Money and MoneyOperators), it is supposed to create classes of purses of different currencies.
# For example, like this:
#
# class MoneyR(Money, MoneyOperators):
#     def __str__(self):
#         return f'MoneyR: {self.money}'
#
#
# class MoneyD(Money, MoneyOperators):
#     def __str__(self):
#         return f'MoneyD: {self.money}'
#
# And, then apply them as follows (these lines do not need to be written in the program):
#
# m1 = MoneyR(1)
# m2 = MoneyD(2)
# m = m1 + 10
# print(m) # MoneyR: 11
# m = m1 - 5.4
# m = m1 + m2


class MoneyOperators:
    def __add__(self, other):
        if type(other) in (int, float):
            return self.__class__(self.money + other)

        if type(self) != type(other):
            raise TypeError("Different types of objects")

        return self.__class__(self.money + other.money)

    def __sub__(self, other):
        if type(other) in (int, float):
            return self.__class__(self.money - other)

        if type(self) != type(other):
            raise TypeError("Different types of objects")

        return self.__class__(self.money - other.money)


class Money:
    def __init__(self, value):
        self.money = value

    @property
    def money(self):
        return self._money

    @money.setter
    def money(self, value):
        if type(value) not in (int, float):
            raise TypeError("sum must be a number")
        self._money = value


class MoneyR(Money, MoneyOperators):
    def __str__(self):
        return f"MoneyR: {self.money}"


class MoneyD(Money, MoneyOperators):
    def __str__(self):
        return f"MoneyD: {self.money}"


m1 = MoneyR(1)
m2 = MoneyD(2)
m = m1 + 10
print(m)  # MoneyR: 11
m = m1 - 5.4
m = m1 + m2  # TypeError
