# Declare a class Note (note), whose objects are created by the command:
#
# note = Note(name, tone)
#
# where name is the name of the note (valid values: do, re, mi, fa, salt, la, si); ton - note key (integer).
# Tonality (ton) takes the following integer values:
#
# -1 - flat (flat);
# 0 - normal note (normal);
# 1 - sharp (sharp).
#
# If invalid values ​​are passed in the name (name) or tone (ton), then an exception is generated by the command:
#
# raise ValueError('invalid argument value')
#
# In each object of the Note class,
# local attributes with the names _name and _ton must be formed with the corresponding values.
#
# Declare a class named Notes whose objects only allow named local attributes (limited via the __slots__ collection):
#
# _do - reference to note before (object of class Note);
# _re - reference to the note re (object of class Note);
# _mi - reference to the note mi (object of class Note);
# _fa - reference to note fa (object of class Note);
# _solt - reference to the salt note (an object of the Note class);
# _la - reference to note la (object of class Note);
# _si - reference to si note (object of class Note).
#
# An object of the Notes class must be created with the command:
#
# notes = notes()
#
# and be only one (at the same time, two or more objects of the Notes class are unacceptable in the program).
# Use the Singleton pattern for this.
#
# At the moment of creating a Notes object, the listed local attributes should be automatically created
# and refer to the corresponding objects of the Note class (tonality (ton) for all notes is initially equal to 0).
#
# Provide the ability to access notes by indices: 0 - to; 1 - re; ... ; 6 - si. For example:
#
# nota = notes[2] # link to note E
# notes[3]._ton = -1 # change the key of note F
#
# If an invalid index is specified (not an integer, or a number outside the interval [0; 6]),
# then an exception is generated by the command:
#
# raise IndexError('invalid index')
#
# Create a notes object of class Notes in the program.


class Note:
    _note_values = "do", "re", "mi", "fa", "solt", "la", "si"

    def __init__(self, name, ton):
        self._name = name
        self._ton = ton

    def __setattr__(self, key, value):
        if key == "_name" and value not in self._note_values:
            raise ValueError("invalid argument value")
        if key == "_ton" and value not in (-1, 0, 1):
            raise ValueError("invalid argument value")
        object.__setattr__(self, key, value)


class Notes:
    __slots__ = "_do", "_re", "_mi", "_fa", "_solt", "_la", "_si"
    _note_values = "do", "re", "mi", "fa", "solt", "la", "si"
    _instance = None

    def __new__(cls, *args, **kwargs):
        if cls._instance is None:
            Notes._instance = super().__new__(cls)
        return cls._instance

    def __del__(self):
        Notes._instance = None

    def __init__(self):
        for key, value in zip(self.__slots__, self._note_values):
            setattr(self, key, Note(value, 0))

    def __getitem__(self, item):
        if not (0 <= item < 7):
            raise IndexError("invalid index")
        return getattr(self, self.__slots__[item])


notes = Notes()
print(*[n._name for n in notes], sep="\n")
