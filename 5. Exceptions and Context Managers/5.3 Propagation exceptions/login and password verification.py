# Declare a class named ValidatorString whose objects are created by the command:
#
# vs = ValidatorString(min_length, max_length, chars)
#
# where min_length, max_length are the minimum and maximum allowable string lengths (integers formed in the range
# [min_length; max_length]); chars - a string from a set of characters (at least one of them must be present in the
# string being checked). If chars is an empty string, then do not check for the occurrence of characters.
#
# In the ValidatorString class itself, declare a method:
#
# def is_valid(self, string): ...
#
# which checks the string string against the criteria: string must be a string, with a length in the range
# [min_length; max_length] and string contains at least one character from chars. If at least one of these criteria
# is not met, then an exception is generated by the command:
#
# raise ValueError('invalid string')
#
# Next, declare a class named LoginForm whose objects are created by the command:
#
# lg = LoginForm(login_validator, password_validator)
#
# where login_validator - login validator (object of ValidatorString class);
# password_validator - password validator (object of ValidatorString class).
#
# In the LoginForm class itself, declare the following method:
#
# def form(self, request): ...
#
# where request is the request object (dictionary). The request dictionary must contain the key 'login' with
# the value of the entered login (string) and the key 'password' with the value of the entered password (string).
# If at least one key is missing, then throw an exception with the command:
#
# raise TypeError('there is no login or password in the request')
#
# Otherwise (if the check for request passed), check the correctness of the login and password received by the form
# using the validators specified in the login_validator and password_validator parameters when creating the form object.
#
# If the login/password is entered correctly, then in the object of the LoginForm class,
# the local attributes _login and _password are assigned the corresponding values.


class ValidatorString:
    def __init__(self, min_length, max_length, chars):
        self.__min_length = min_length
        self.__max_length = max_length
        self.__chars = chars

    def is_valid(self, string):
        if not self.__min_length <= len(string) <= self.__max_length or \
                self.__chars and not any(char in self.__chars for char in string):
            raise ValueError("invalid string")
        return string


class LoginForm:
    def __init__(self, login_validator, password_validator):
        self.login_validator = login_validator
        self.password_validator = password_validator
        self._login = self._password = None

    def form(self, request):
        if not request.get("login") or not request.get("password"):
            raise TypeError("the request does not contain a username or password")
        self._login = self.login_validator.is_valid(request.get("login"))
        self._password = self.password_validator.is_valid(request.get("password"))


login_v = ValidatorString(4, 50, "")
password_v = ValidatorString(10, 50, "!$#@%&?")
lg = LoginForm(login_v, password_v)
login, password = input().split()
try:
    lg.form({'login': login, 'password': password})
except (TypeError, ValueError) as e:
    print(e)
else:
    print(lg._login)
