# Declare the FloatValidator class in the program, the objects of which are created by the command:
#
# fv = FloatValidator(min_value, max_value)
#
# where min_value, max_value are the minimum and maximum allowable values ​​(range [min_value; max_value]).
#
# Objects of this class are supposed to be used as follows:
#
# fv(value)
#
# where value is the value being checked. If value is not a real number or does not belong
# to the range [min_value; max_value], then an exception is generated by the command:
#
# raise ValueError('value not validated')
#
# By analogy, declare an IntegerValidator class whose objects are created by the command:
#
# iv = IntegerValidator(min_value, max_value)
#
# and used by the command:
#
# iv(value)
#
# An exception is also thrown here:
#
# raise ValueError('value not validated')
#
# if value is not an integer or does not belong to the range [min_value; max_value].
#
# After that, declare the function with signature:
#
# def is_valid(lst, validators): ...
#
# where lst is a list of data; validators - a list of validator objects
# (objects of the FloatValidator and IntegerValidator classes).
#
# This function should select from the list all values ​​that have passed through at least one validator.
# And return a new list with elements that passed the test.
#
# An example of using classes and functions (do not write these lines in the program):
#
# fv = FloatValidator(0, 10.5)
# iv = IntegerValidator(-10, 20)
# lst_out = is_valid([1, 4.5, -10.5, 100, True, 'abc', (1, 2)], validators=[fv, iv]) # [1, 4.5]


class FloatValidator:
    def __init__(self, min_value, max_value):
        self.min_value = min_value
        self.max_value = max_value

    def __call__(self, value):
        if type(value) != float or not (self.min_value <= value <= self.max_value):
            raise ValueError("value not validated")


class IntegerValidator:
    def __init__(self, min_value, max_value):
        self.min_value = min_value
        self.max_value = max_value

    def __call__(self, value):
        if type(value) != int or not (self.min_value <= value <= self.max_value):
            raise ValueError("value not validated")


def is_valid(lst, validators):
    res = []
    for x in lst:
        for v in validators:
            try:
                v(x)
                res.append(x)
                break
            except ValueError:
                pass
    return res


fv = FloatValidator(0, 10.5)
iv = IntegerValidator(-10, 20)
lst_out = is_valid([1, 4.5, -10.5, 100, True, 'abc', (1, 2)], validators=[fv, iv])
print(lst_out)
