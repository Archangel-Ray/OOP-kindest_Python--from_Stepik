# You need to implement a playing field for the game 'Tic-tac-toe' in the program. To do this, you need to declare
# the TicTacToe (tic-tac-toe) class, the objects of which are created by the command:
#
# game = TicTacToe()
#
# Every game object must have a public attribute:
#
# pole - playing field: a 3x3 tuple with objects of the Cell class.
#
# Each cell of the playing field is represented by an object of the Cell class and is created by the command:
#
# cell = Cell()
#
# Objects of class Cell must have the following public local attributes:
#
# is_free - True if the cell is free; False otherwise;
# value - field value: 1 - cross; 2 - zero (default 0).
#
# Also, a function should work with each object of the Cell class:
#
# bool(cell)
#
# which returns True if the cell is free (cell.is_free=True) and False otherwise.
#
# The TicTacToe class must have the following method:
#
# clear() - clearing the playing field (all cells are filled with zeros and transferred to the closed state);
#
# And objects of this class should have the following functionality (reference by indexes):
#
# game[0, 0] = 1 # set a new value if the field is closed
# res = game[1, 1] # getting the value of the central cell of the field (a number is returned)
#
# If incorrect indexes are specified, then an exception should be generated by the command:
#
# raise IndexError('invalid cell index')
#
# If there is an attempt to assign a new value to an open field cell, then throw an exception:
#
# raise ValueError('cell already occupied')
#
# The following full cuts must also be implemented when accessing the cells of the playing field:
#
# slice_1 = game[:, indx] # all elements (tuple) of the column with index indx are selected
# slice_2 = game[indx, :] # all elements (tuple) of the row with index indx are selected
#
# An example of using classes (do not write these lines in the program):
#
# game = TicTacToe()
# game.clear()
# game[0, 0] = 1
# game[1, 0] = 2
# # the field is formed:
# # 100
# #200
# # 0 0 0
# game[3, 2] = 2 # an IndexError is thrown
# if game[0, 0] == 0:
# game[0, 0] = 2
# v1 = game[0, :] # 1, 0, 0
# v2 = game[:, 0] # 1, 2, 0
#
# P.P.S. When passing a slice in the __setitem__() and __getitem__() magic methods,
# the index parameter becomes an object of the slice class. It can be specified directly
# in square brackets of ordered collections (lists, tuples, etc.).


class Cell:
    def __init__(self):
        self.is_free = True
        self.value = 0

    def __bool__(self):
        return self.is_free


class TicTacToe:
    def __init__(self):
        self.pole = tuple(tuple(Cell() for _ in range(3)) for _ in range(3))

    def clear(self):
        for row in self.pole:
            for cell in row:
                cell.is_free = True
                cell.value = 0

    def __check(self, indx):
        if type(indx) != tuple or len(indx) != 2:
            raise IndexError('invalid cell index')
        if any(not (0 <= x < 3) for x in indx if type(x) != slice):
            raise IndexError('invalid cell index')

    def __setitem__(self, key, value):
        self.__check(key)
        if self.pole[key[0]][key[1]]:
            self.pole[key[0]][key[1]].value = value
            self.pole[key[0]][key[1]].is_free = False
        else:
            raise ValueError('cell is already occupied')

    def __getitem__(self, item):
        self.__check(item)
        if type(item[0]) == slice:
            return tuple(self.pole[x][item[1]].value for x in range(3))
        if type(item[1]) == slice:
            return tuple(self.pole[item[0]][x].value for x in range(3))
        return self.pole[item[0]][item[1]].value


game = TicTacToe()
game.clear()
game[0, 0] = 1
game[1, 0] = 2
# game[3, 2] = 2
if game[0, 0] == 0:
    game[0, 0] = 2
v1 = game[0, :]
v2 = game[:, 0]
print(v1, v2)
for i in range(3):
    print(*game[i, :])
game.clear()
print()
