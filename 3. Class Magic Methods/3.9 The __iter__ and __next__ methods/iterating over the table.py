# The program needs to implement the TableValues ​​table according to the following scheme:
#
# Each table cell must be represented by the Cell class. Objects of this class are created by the command:
#
# cell = Cell(data)
#
# where data is the data in the cell. Each object of the Cell class must have a local private __data attribute
# with the appropriate value. To work with it, the Cell class must have a property object:
#
# data - for writing and reading information from the __data attribute.
#
# The TableValues ​​class itself represents the table as a whole, the objects of which are created by the command:
#
# table = TableValues(rows, cols, type_data)
#
# where rows, cols - the number of rows and columns of the table; type_data - cell data type (int - by default,
# float, list, str, etc.). The initial values ​​in the table cells are 0 (integer).
#
# The following commands must be executed on objects of the TableValues ​​class:
#
# table[row, col] = value  # writing a new value to a cell with indices row, col (indices are zero-based)
# value = table[row, col]  # reading the value from the cell with indices row, col
#
# for row in table:  # iterate over rows
#     for value in row:  # iterate over columns
#         print(value, end=' ')  # print cell values ​​to console
#     print()
#
# When trying to write data of a different type by table[row, col] indexes (not matching the type_data attribute
# of an object of the TableValues ​​class), an exception should be generated by the command:
#
# raise TypeError('wrong type of data being assigned')
#
# When working with indexes row, col, it is necessary to check their correctness. If the indexes are not an integer
# or they are out of the table size range, then throw an exception with the command:
#
# raise IndexError('invalid index')


class Cell:
    def __init__(self, data=0):
        self.data = data

    @property
    def data(self):
        return self.__data

    @data.setter
    def data(self, data):
        self.__data = data


class TableValues:
    def __init__(self, rows, cols, type_data=int):
        self.__rows = rows
        self.__cols = cols
        self.__type_data = type_data
        self.__cells = tuple(tuple(Cell() for _ in range(cols)) for _ in range(rows))

    def __check_index(self, indx):
        if not (0 <= indx[0] < self.__rows) or not (0 <= indx[1] < self.__cols):
            raise IndexError("invalid index")

    def __getitem__(self, item):
        self.__check_index(item)
        return self.__cells[item[0]][item[1]].data

    def __setitem__(self, key, value):
        self.__check_index(key)
        if type(value) != self.__type_data:
            raise TypeError("wrong type of assigned data")
        self.__cells[key[0]][key[1]].data = value

    def __iter__(self):
        for row in self.__cells:
            yield (x.data for x in row)


table = TableValues(5, 4)
table[3, 2] = 5
value = table[3, 2]

for row in table:
    for value in row:
        print(value, end=' ')
    print()
